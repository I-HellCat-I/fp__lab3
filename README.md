# Отчет по лабораторной работе №3
## "Функциональное программирование"

**Тема:** Интерполяция функций (Потоковая обработка данных)
**Язык:** Haskell

**Выполнил:** Студент группы P3312 
Лобов Максим Павлович

---

### 1. Требования к разработанному ПО

Целью работы является получение навыков работы с вводом/выводом, потоковой обработкой данных и аргументами командной строки в функциональном стиле.

**Функциональные требования:**
1.  **Алгоритмы интерполяции:**
    *   Линейная интерполяция (по 2 точкам).
    *   Интерполяция Лагранжа / Ньютона (по $N$ точкам).
    *   Интерполяция Гаусса (требует равномерной сетки и нечетного количества узлов).
2.  **Потоковый режим:**
    *   Программа должна читать данные со стандартного ввода (`stdin`) по мере их поступления.
    *   Вывод рассчитанных точек должен происходить немедленно, не дожидаясь конца ввода (поддержка бесконечных потоков).
    *   Реализован механизм "скользящего окна" (Sliding Window): окно размера $N$ сдвигается на одну точку вперед на каждом шаге.
3.  **Конфигурация:**
    *   Параметры задаются через аргументы командной строки (`--linear`, `--newton`, `--step`, `--window`).
    *   Входные данные: текстовый формат (пары $x, y$), отсортированные по возрастанию $x$.

**Описание алгоритма (Скользящее окно):**
1.  Накапливается буфер из $N$ точек (где $N$ — размер окна).
2.  Вычисляются промежуточные значения интерполяции с заданным шагом (`step`) для текущего окна.
    *   Для обеспечения наилучшей точности алгоритмов Ньютона/Лагранжа, вычисления производятся в окрестности центра окна.
    *   Как только текущая точка $x$ выходит за середину окна, происходит сдвиг.
3.  Сдвиг окна: удаляется первая точка, считывается новая точка из потока, процесс повторяется.
4.  При достижении конца потока (`EOF`) алгоритм дочитывает интервал на оставшихся данных.

---

### 2. Ключевые элементы реализации

#### 2.1. Математическое ядро (`src/Interpolation.hs`)

Реализация алгоритма Ньютона через разделенные разности. Использована свертка (`foldl'`) для эффективного вычисления коэффициентов за один проход без явной рекурсии, что предотвращает переполнение стека.

```haskell
-- | Вычисление разделенных разностей (коэффициентов полинома Ньютона)
dividedDifferences :: [Double] -> [Double] -> [Double]
dividedDifferences xs ys = 
    -- foldl' накапливает коэффициенты верхней диагонали таблицы разностей
    let (finalAcc, finalYs) = foldl' step ([], ys) [1 .. length xs - 1]
    in reverse (head finalYs : finalAcc) 
  where
    step (acc, currentYs) k =
        case currentYs of
            (c_current : _) -> 
                let 
                    -- Вычисляем следующий слой разностей: (y[i+1] - y[i]) / (x[i+k] - x[i])
                    yPairs = zip currentYs (drop 1 currentYs)
                    xPairs = zip xs (drop k xs)
                    nextYs = zipWith (\(y0, y1) (x0, x1) -> (y1 - y0) / (x1 - x0)) 
                                     yPairs xPairs
                in (c_current : acc, nextYs)
            [] -> (acc, [])
```

#### 2.2. Потоковая обработка (`processStream`)

Функция принимает ленивый список входных точек и рекурсивно обрабатывает их окнами. Использование `takeWhile` генерирует точки интерполяции. `drop 1` безопасно сдвигает окно.

```haskell
processStream :: Config -> [Point] -> [InterpolationResult]
processStream cfg inputStream =
   go wSize [] inputStream Nothing
  where
    -- Рекурсивная функция с состоянием (окно, остаток входа, текущий X)
    go wSize window inputStream nextX =
      -- 1. Определяем границы расчета для текущего окна
      let currX = fromMaybe (fst $ head window) nextX
          limitIndex = if not (null inputStream) then wSize `div` 2 else wSize - 1
          limitX = fst (window !! limitIndex)

          -- 2. Генерируем точки с заданным шагом
          pointsToCalc = takeWhile (<= limitX + 1e-9) [currX, currX + step ..]

          -- 3. Вычисляем значения
          results = concatMap (\xVal -> ... ) pointsToCalc
          
          newNextX = if null pointsToCalc then currX else last pointsToCalc + step

          -- 4. Сдвигаем окно и идем в рекурсию
          nextStep = case inputStream of
            (newP : restInput) ->
              let newWindow = drop 1 window ++ [newP]
               in go wSize newWindow restInput (Just newNextX)
            [] -> [] -- Конец потока
       in results ++ nextStep -- Ленивая конкатенация
```

#### 2.3. Ввод/Вывод (`app/Main.hs`)

Используется `getContents` для ленивого чтения всего `stdin` как одной большой строки. Это позволяет программе работать в стиле Unix-фильтров (`cat data.txt | lab3`).

```haskell
main :: IO ()
main = do
    -- Парсинг конфига
    args <- getArgs
    let config = parseArgs args defaultConfig

    -- Ленивое чтение
    inputContent <- getContents
    let points = mapMaybe parseLine (lines inputContent)

    -- Запуск потока и печать результатов по мере их появления
    mapM_ (putStrLn . formatResult) (processStream config points)
```

---

### 3. Ввод/Вывод программы

**Пример 1: Линейная интерполяция**
```bash
$ printf "0 0\n1 1\n2 2\n3 3" | stack exec lab3-exe -- --linear --step 0.5

linear: 0 0
linear: 0.5 0.5
linear: 1 1
linear: 1.5 1.5
linear: 2 2
linear: 2.5 2.5
linear: 3 3
```

**Пример 2: Интерполяция Ньютона и Гаусса (окно 3 точки)**
```bash
$ printf "0 0\n1 1\n2 4\n3 9\n4 16" | stack exec lab3-exe -- --newton --gauss --window 3 --step 0.5

newton: 0 0
gauss: 0 0
newton: 0.5 0.25
gauss: 0.5 0.25
...
newton: 2.5 6.25  <-- Точное значение для y=x^2
gauss: 2.5 6.25
...
```

---

### 4. Выводы

В ходе лабораторной работы были реализованы численные методы интерполяции с использованием парадигмы функционального программирования.

**Сравнение с императивным подходом (Python/C++):**

1.  **Ленивые вычисления (Lazy Evaluation):**
    В Haskell функция `getContents` позволяет работать с бесконечным потоком ввода так, как будто это обычный список в памяти. В Python для реализации аналогичного поведения ("cat | grep") пришлось бы писать явный цикл `while True: readline()`, управлять буфером вручную и следить за его наполнением. В Haskell вся логика "буферизации" скрыта за абстракцией ленивого списка и рекурсией.

2.  **Чистота функций:**
    Математические алгоритмы (`dividedDifferences`, `gaussInterp`) реализованы как чистые функции без побочных эффектов. Это упростило тестирование: для проверки алгоритма Ньютона не нужно создавать файлы или мокать ввод-вывод, достаточно передать список точек.

3.  **Безопасность типов:**
    Использование `Maybe` и сопоставления с образцом (`case window of ...`) вместо индексов массивов позволило избежать классических ошибок "выход за границы массива" или `NullReferenceException`. Компилятор принудил обработать случаи пустого окна или недостатка данных.

4.  **Декларативность:**
    Код алгоритмов (например, формула Лагранжа или Гаусса) выглядит практически как математическая формула (`sum $ map term ...`), что повышает читаемость по сравнению с вложенными циклами `for` в императивных языках.

**Итог:** Использование Haskell позволило лаконично реализовать сложную логику скользящего окна и математических вычислений, разделив ответственность между "грязным" вводом-выводом и "чистым" вычислительным ядром.
